#!/bin/bash

# Usage: strip_flags <...all_arguments>
# echo $CURRENT_CLEAN_ARGUMENTS
CURRENT_CLEAN_ARGUMENTS=()
function strip_flags() {
  CURRENT_CLEAN_ARGUMENTS=()
  for argument in "$@"; do
    if [[ "$argument" =~ ^- ]]; then
      continue
    fi
    CURRENT_CLEAN_ARGUMENTS+=("$argument")
  done
}

# Usage: check_contains_flag <all_arguments> <flag_long_name> <flag_shorthand>
# Example: check_contains_flag "$*" 'help' 'h'
function check_contains_flag() {
  if [[ "$1" =~ --$2 ]] || [[ "$1" =~ -$3 ]]; then
    echo 'true'
  fi
}

# Usage: extract_flag_value <all_arguments> <flag_name>
function extract_flag_value() {
  echo "$1" | grep -Eo "$2\=[^\s+]+" | grep -Eo '[^ \=]+$'
}

function git_current_branch() {
  git branch | grep '\*' | cut -d ' ' -f2
}

function git_backup() {
  git checkout "$1" && git checkout -b "$2" && git checkout "$1"
}

function git_commit() {
  git add --all :/ && git commit
}

if ! git -C "$(pwd)" rev-parse --is-inside-work-tree &> /dev/null; then
  echo "$(pwd) is not a git repository."
  exit 1
fi

if [ -n "$(check_contains_flag "$*" "help" "h")" ]; then
  echo """Usage: git squash [--help|-h] [--backup=<branch_name>] [--backup|-b] [--reset|-r] [<base_branch>]

Arguments
  base_branch    Branch that is used to grab the base commit to squash from (default: master)

Flags
  --reset|-r     Squashes without first updating the branch. By default we use a rebase which updates the branch before squashing.
  --backup       Back up the branch before squashing to '[target_branch]-backup'. --backup accepts a backup branch name.
  --help|-h      Print this help message"""
  exit 0
fi

strip_flags $*
base_branch="${CURRENT_CLEAN_ARGUMENTS[1]:-master}"
target_branch="$(git_current_branch)"

if [ -n "$(extract_flag_value "$*" "backup")" ]; then
  backup_branch="$(extract_flag_value "$*" "backup")"
elif [ -n "$(check_contains_flag "$*" "backup" "b")" ]; then
  backup_branch="$target_branch-backup"
fi

if [ "$base_branch" == "$target_branch" ]; then
  echo "Base branch $base_branch can't be the same as the target branch $target_branch."
  exit 1
fi

if [ -n "$backup_branch" ]; then
  if ! git_backup "$target_branch" "$backup_branch"; then
    echo "Backing up $target_branch to $backup_branch failed."
    exit 1
  fi
fi

if [ -z "$(check_contains_flag "$*" "reset" "r")" ]; then
  if ! GIT_SEQUENCE_EDITOR="sed -i -e '1 ! s/pick/squash/g'" git rebase -i --autostash "$base_branch"; then
    exit 1
  fi
  exit 0
fi

if git merge-base "$base_branch" "$target_branch" &> /dev/null; then
  squash_from_commit="$(git merge-base "$base_branch" "$target_branch")"
else
  echo "Error finding commit to squash from"
  exit 1
fi

if ! git reset "$squash_from_commit"; then
  echo "Squashing $target_branch failed. Tried to use commit hash $squash_from_commit."
  exit 1
fi

if ! git_commit; then
  echo "'git reset' worked but failed to create a new squash commit. Please manually run 'git add --all && git commit'."
  exit 1
fi

done_message="Done. Pushing will require a force push (e.g. git push origin $target_branch --force)."

if [ -n "$backup_branch" ]; then
  echo "$done_message Backup in $backup_branch."
else
  echo "$done_message"
fi
